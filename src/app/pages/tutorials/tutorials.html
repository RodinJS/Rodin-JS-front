<svg xmlns="http://www.w3.org/2000/svg"
     style="border: 0 !important; clip: rect(0 0 0 0) !important; height: 1px !important; margin: -1px !important; overflow: hidden !important; padding: 0 !important; position: absolute !important; width: 1px !important;"
     class="root-svg-symbols-element">
    <symbol id="extensibly" viewBox="0 0 32 32">
        <path fill="#14273c"
              d="M2.17.542h9.763v11.39H2.17V.542zm14.644 0h9.763v11.39h-9.763V.542zM2.17 15.729h9.763v11.39H2.17v-11.39z"/>
        <path fill="#008bf2"
              d="M1.247.271C.705.325.271.759.271 1.301v10.468c0 .597.488 1.03 1.03 1.03h10.468c.597 0 1.03-.488 1.03-1.03V1.301c0-.597-.488-1.03-1.03-1.03H1.247zM16 .271c-.597 0-1.03.488-1.03 1.03v10.468c0 .597.488 1.03 1.03 1.03h10.468c.597 0 1.03-.488 1.03-1.03V1.301c0-.542-.434-.976-.976-1.03H16zM2.386 2.386h8.407v8.407H2.386V2.386zm14.644 0h8.407v8.407H17.03V2.386zM1.247 14.97c-.542.054-.976.488-.976 1.03v10.468c0 .597.488 1.03 1.03 1.03h10.468c.597 0 1.03-.488 1.03-1.03V16c0-.597-.488-1.03-1.03-1.03H1.247zm14.753 0c-.597 0-1.03.488-1.03 1.03v10.468c0 .597.488 1.03 1.03 1.03h2.603c.38 0 .705-.217.922-.542s.217-.705 0-1.03c-.217-.325-.542-.542-.922-.542H17.03v-8.407h8.407v1.573c0 .38.217.705.542.922s.705.217 1.03 0c.325-.217.542-.542.542-.922v-2.603c0-.542-.434-.976-.976-1.03H15.999zM2.386 17.03h8.407v8.407H2.386V17.03zm23.973 4.177c-.542.054-.922.542-.922 1.085v3.146h-3.254c-.38 0-.705.217-.868.542s-.163.759.054 1.03.542.488.922.488h3.146v3.146c0 .38.217.705.542.922s.705.217 1.03 0c.325-.217.542-.542.542-.922v-3.146h3.146c.38 0 .705-.217.922-.542s.217-.705 0-1.03c-.217-.325-.542-.542-.922-.542h-3.146v-3.146c0-.325-.108-.597-.325-.814-.271-.108-.542-.217-.868-.217z"
        />
    </symbol>
    <symbol id="javascript" viewBox="0 0 41 32">
        <path fill="#14273c"
              d="M1.745 1.745H38.4c.643 0 1.164.521 1.164 1.164v27.345c0 .643-.521 1.164-1.164 1.164H1.745a1.164 1.164 0 0 1-1.164-1.164V2.909c0-.643.521-1.164 1.164-1.164z"/>
        <path fill="#008bf2"
              d="M2.764.167A2.779 2.779 0 0 0 0 2.931v27.643c0 .509.413.921.921.921h38.7a.921.921 0 0 0 .921-.921V2.931A2.779 2.779 0 0 0 37.778.167H2.764zm0 1.843h35.014a.9.9 0 0 1 .921.921v3.686H1.842V2.931a.9.9 0 0 1 .921-.921zm1.843 1.382a.921.921 0 0 0 0 1.842H12.9a.921.921 0 0 0 0-1.842H4.607zM1.843 8.46H38.7v21.193H1.843V8.46zm20.156 3.239c-.362.045-.683.296-.777.648l-3.686 12.9c-.132.467.164 1.029.633 1.152.471.123 1.02-.181 1.152-.648l3.686-12.9c.179-.589-.398-1.236-1.008-1.152zm-6.882 1.814a.927.927 0 0 0-.403.144l-7.371 4.607a.927.927 0 0 0 0 1.569l7.371 4.607c.411.256 1.025.108 1.281-.302s.109-1.011-.302-1.267l-6.119-3.815 6.119-3.83c.366-.21.552-.694.418-1.094s-.575-.673-.993-.619zm10.179 0c-.396.011-.764.308-.864.691s.077.82.418 1.022l6.119 3.83-6.119 3.815c-.411.256-.544.856-.288 1.267s.856.559 1.267.302l7.371-4.607c.618-.387.533-1.241 0-1.569l-7.371-4.607a.935.935 0 0 0-.533-.144z"
        />
    </symbol>
    <symbol id="multiplatform" viewBox="0 0 53 32">
        <path fill="#14273c"
              d="M49.938 11.081l.165 11.997-.094 6.605-1.905 1.686-18.3.06-2.769-2.515-1.747.183-2.763 2.059-14.871-.152-3.981-.292-.887-1.696.071-19.089 2.309-1.231 28.055-.039 14.83.291z"/>
        <path fill="#008bf2"
              d="M47.291 16.838c-.454 0-.757-.305-.757-.762v-3.2c0-.686-.605-1.295-1.286-1.295H8.399c-.454 0-.757-.305-.757-.762s.303-.762.757-.762h36.849c1.513 0 2.8 1.219 2.8 2.819v3.2c0 .381-.378.762-.757.762z"/>
        <path fill="#008bf2"
              d="M52.058 15.314h-1.135v-4.267c0-2.057-1.665-3.733-3.708-3.733h-18.16V1.219c0-.457-.303-.762-.757-.762h-3.783c-.454 0-.757.305-.757.762v6.095H5.598c-2.043 0-3.708 1.676-3.708 3.733v4.267H.755c-.454 0-.757.305-.757.762v6.857c0 .457.303.762.757.762H1.89v4.267c0 2.057 1.665 3.733 3.708 3.733h15.663c1.286 0 2.573-.686 3.178-1.905.378-.686 1.135-1.143 1.892-1.143s1.513.381 1.892 1.143c.681 1.143 1.892 1.905 3.178 1.905h15.663c2.043 0 3.708-1.676 3.708-3.733v-4.267h1.135c.454 0 .757-.305.757-.762v-6.857c.151-.457-.227-.762-.605-.762zM1.892 22.171h-.378v-5.333h.378v5.333zm23.38-20.266h2.27v5.333h-2.27V1.905zm24.213 14.171v11.886h-.076c0 1.219-.984 2.21-2.194 2.21H31.552c-.757 0-1.513-.457-1.892-1.143-.681-1.143-1.892-1.905-3.178-1.905-1.362 0-2.573.686-3.178 1.905-.378.686-1.135 1.143-1.892 1.143H5.674a2.203 2.203 0 0 1-2.194-2.21V11.048c0-1.219.984-2.21 2.194-2.21H47.29c1.211 0 2.194.99 2.194 2.21v5.029zm1.816 6.095h-.378v-5.333h.378v5.333z"
        />
        <path fill="#008bf2"
              d="M18.689 24.381a.685.685 0 0 1-.53-.229c-.303-.305-.227-.762.076-1.067l9.08-8.229c.303-.305.757-.229 1.059.076s.227.762-.076 1.067l-9.08 8.229c-.227.076-.378.152-.53.152zm5.297 0a.685.685 0 0 1-.53-.229c-.303-.305-.227-.762.076-1.067l9.08-8.229c.303-.305.757-.229 1.059.076s.227.762-.076 1.067l-9.08 8.229c-.227.076-.378.152-.53.152z"
        />
    </symbol>
    <symbol id="spinner" viewBox="0 0 32 32">
        <path fill="#14273c"
              d="M31.725 16.149c0 8.677-7.04 15.712-15.725 15.712S.275 24.827.275 16.149C.275 7.472 7.315.437 16 .437s15.725 7.034 15.725 15.712z"/>
        <path fill="#008bf2"
              d="M6.146 22.329c-.175-.314-.384-.628-.524-.943-.524-.978-1.747-1.397-2.726-.873s-1.398 1.711-.874 2.723c.21.419.454.873.734 1.257.384.594 1.048.943 1.677.943.384 0 .769-.105 1.083-.314a2.029 2.029 0 0 0 .629-2.793zm4.368 3.98c-.315-.175-.629-.349-.943-.559-.943-.594-2.201-.314-2.796.594-.594.943-.314 2.2.594 2.793.419.279.839.524 1.258.733.28.14.629.209.943.209.734 0 1.433-.384 1.782-1.082.524-.943.14-2.2-.839-2.688zm5.102-21.577h.105c1.118 0 2.027-.908 2.027-2.025S16.839.682 15.721.682h-.175c-1.118.035-1.992 1.013-1.922 2.13.07 1.082.943 1.92 1.992 1.92zm1.013 22.799c-.28.035-.559.035-.874.035h-.559a2.054 2.054 0 0 0-2.132 1.92c-.035 1.117.804 2.06 1.922 2.095h.769c.384 0 .769 0 1.153-.035a1.982 1.982 0 0 0 1.852-2.165c-.07-1.082-1.048-1.92-2.132-1.85zM2.407 18.837c1.118-.035 1.992-1.013 1.922-2.095v-.663a2.028 2.028 0 0 0-4.054 0v.873c.035 1.082.943 1.92 2.027 1.92h.105v-.035zm26.872-1.152c-1.083-.279-2.201.349-2.481 1.431a9.196 9.196 0 0 1-.594 1.641c-.454 1.013 0 2.2 1.013 2.654a2.4 2.4 0 0 0 .839.175 2.07 2.07 0 0 0 1.852-1.187c.314-.733.594-1.501.769-2.235a2.004 2.004 0 0 0-1.398-2.479zM8.941 6.582c.349 0 .699-.07 1.048-.279l.105-.07c.978-.559 1.328-1.781.769-2.758s-1.782-1.327-2.761-.768l-.21.105a1.99 1.99 0 0 0-.664 2.758c.384.663 1.013 1.013 1.712 1.013zm22.784-2.095c0-1.117-.909-2.025-1.992-2.025h-7.268a2.028 2.028 0 0 0-2.027 2.025v7.227a2.028 2.028 0 0 0 4.054 0V8.781a11.68 11.68 0 0 1 2.271 4.26c.105.419.14.559.175.838.175.943 1.048 1.606 1.957 1.606.14 0 .28 0 .419-.035 1.083-.21 1.782-1.292 1.572-2.374-.035-.279-.14-.628-.28-1.152-.559-1.955-1.538-3.806-2.796-5.412h1.887a2.028 2.028 0 0 0 2.027-2.025zm-8.701 20.46c-.454.384-.909.733-1.433 1.013-.943.559-1.258 1.816-.699 2.758a2.021 2.021 0 0 0 1.712.978c.349 0 .699-.07 1.048-.279a15.303 15.303 0 0 0 1.957-1.397c.839-.698.978-1.99.245-2.863-.664-.803-1.957-.908-2.83-.209zM3.036 11.261c.943.489 2.097.314 2.761-.768l.07-.14c.559-.943.245-2.2-.699-2.758s-2.201-.244-2.761.733l-.105.175c-.559.978-.245 2.235.734 2.758z"
        />
    </symbol>
    <symbol id="upload" viewBox="0 0 31 32">
        <path fill="#008bf2"
              d="M25.611 31.484H5.322c-2.401 0-4.348-1.972-4.348-4.404V15.336c0-2.433 1.946-4.404 4.348-4.404h5.797v2.936H5.322c-.8 0-1.449.658-1.449 1.468V27.08c0 .81.649 1.468 1.449 1.468h20.289c.8 0 1.449-.658 1.449-1.468V15.336a1.46 1.46 0 0 0-1.449-1.468h-5.797v-2.936h5.797c2.401 0 4.348 1.972 4.348 4.404V27.08c0 2.433-1.946 4.404-4.348 4.404zm-8.695-8.808h-2.898V8.006H8.221l7.246-7.35 7.246 7.35h-5.797v14.67z"
        />
    </symbol>
</svg>

<div class="content-pages">
    <!--<div class="container page static">-->
    <!--<div class="row text-white" >-->
    <!--<h1 class="text-center text-white" style="text-align: center;color:#fff; margin-bottom:30px">-->
    <!--{{$ctrl.page.title}}</h1>-->
    <!--<div ng-bind-html="$ctrl.page.content.extended | htmlize" codify></div>-->
    <!--</div>-->
    <!--</div>-->
    <div class="container-fluid page static-pages">
        <div class="row title-section">
            <h1 class="title text-center">TUTORIAL</h1>
            <span class="line"></span>
        </div>
        <div class="content-pages tutorial" codify>
            <div class="container page static">
                <div class="col-md-3 rd-tree">
                    <ul class="nav nav-list">
                        <li class="labeled"><label class="tree-toggler nav-header">RODIN LIB BASIC DOC</label>
                        </li>
                        <li class="labeled"><label class="tree-toggler nav-header">SCENE</label>
                        </li>
                        <li class="labeled"><label class="tree-toggler nav-header">SCULPT</label>
                            <ul class="nav nav-list tree">
                                <li><a>Main Information</a></li>
                                <li><a>Sources</a></li>
                            </ul>
                        </li>
                    </ul>
                </div>
                <div class="col-md-8 tutorial-section">
                    <section class="tutorial-content">
                        <h1>RODIN LIB BASIC DOC</h1>
                        <article>
                            <p>A basic VR experience in Rodin starts with the following two lines:</p>
                            <p class="indent">First, you import the components of the library. <span
                                    class="block"> <code
                                    class="common">import * as RODIN from 'rodin/core';</code> </span></p>
                            <p class="indent">Then, you start the rendering loop (<code
                                    class="common">animationFrame</code> loop). <span class="block"> <code
                                    class="common">RODIN.start();</code> </span></p>
                            <p class="code-desc"><code class="common">animationFrame</code> loops up to the frequency
                                limited by the VRDisplay (60 fps for Mobiles and PCs, 90 fps for advanced VR Headsets,
                                etc.)</p>
                            <div class="section-footer">
                                <p>See <a
                                        href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame"
                                        target="_blank">window.requestAnimationFrame()</a> for details.</p>
                            </div>
                        </article>
                    </section>
                    <section class="tutorial-content">
                        <h1>SCENE</h1>
                        <article>
                            <p>In Rodin, you build your experience in scenes. You may have multiple scenes in your
                                project and switch from one to another whenever it&rsquo;s needed.</p>
                            <p>After the <code class="common">RODIN.start()</code> call, Rodin creates a default scene
                                and sets it as the <code class="common">active</code> one.</p>
                            <p>The <code class="common">animationFrame</code> loop will render the active scene only.
                            </p>
                            <p>Whenever you add an object to <code class="common">RODIN.Scene</code>, it is
                                automatically added to the <code class="common">active</code> scene:</p>
                            <p class="indent"><code class="common">RODIN.Scene.add(object);</code></p>
                            <p>To create other scenes, just create a new object:</p>
                            <p class="indent"><code class="common">let scene2 = new RODIN.Scene(&ldquo;mySecondScene&rdquo;).</code>
                            </p>
                            <p>To add objects to non-active scene:</p>
                            <p class="indent"><code class="common">scene2.add(object);</code></p>
                            <p>To change the <code class="common">active</code> scene, use one of the following:</p>
                            <p class="indent line-through">by the scene name</p>
                            <p class="indent"><code class="common"><span class="line-through">RODIN.Scene.go(&ldquo;mySecondScene&rdquo;);</span>
                                not ready yet</code></p>
                            <p class="indent">by the scene object</p>
                            <p class="indent"><code class="common">RODIN.Scene.go(scene2);</code></p>
                            <p class="indent">by the scene index (first scene has the index 0)</p>
                            <p class="indent"><code class="common">RODIN.Scene.go(1);</code></p>
                            <p>The <code class="common">Rodin.Scene</code> controls the rendering loop in its <code
                                    class="common">render()</code> function, which is called on every animation frame.
                            </p>
                            <p>If you want a custom function to be called on each cycle, you can add it to</p>
                            <p class="indent"><code class="common">RODIN.Scene.preRender(myFunc)</code> &ndash; to be
                                called before rendering the scene</p>
                            <p class="indent">or</p>
                            <p class="indent"><code class="common">RODIN.Scene.postRender(myFunc)</code> &ndash; to be
                                called after rendering the scene.</p>
                            <p>In the case above, the <code class="common">myFunc</code> will be called on every frame
                                render, disregarding which scene is active.</p>
                            <p>If you want the myFunc to be called only when the current scene is active, use the
                                following:</p>
                            <p class="indent"><code class="common">RODIN.Scene.preRender(myFunc)</code> &ndash; to be
                                called before rendering the scene</p>
                            <p class="indent">or</p>
                            <p class="indent"><code class="common">RODIN.Scene.postRender(myFunc)</code> &ndash; to be
                                called after rendering the scene.</p>
                            <p>This way when you switch to another scene, myFunc will not be called.</p>
                            <p>Let&rsquo;s look at a basic example of how you can create two different scenes and switch
                                between them by mouse click:</p>
                            <div class="code-box"><pre id="rodinCode" class="code-block"><code class="code">
                                import * as RODIN from 'rodin/core';
                                RODIN.start();
                                let scene2 = new RODIN.Scene("mySecondScene");
                                let currentSceneIndex = 0;

                                let counter = 0;

                                RODIN.Scene.preRender(() =&gt; {
                                    if (++counter % 60 === 0) {
                                        console.log(RODIN.Scene.active.name)
                                    }
                                });

                                document.addEventListener('click', function () {
                                    currentSceneIndex = (currentSceneIndex + 1) % 2;
                                    RODIN.Scene.go(currentSceneIndex);
                                });
                            </code>
                        </pre>
                                <p class="code-box-title">Example 1</p>
                            </div>
                            <p>In Example 1, you can see that the first scene is created by running the <code>RODIN.start()</code>
                                function.</p>
                            <p>The second scene is created manually. Since we know that there are two scenes, indexed
                                accordingly as 0 and 1, we can switch between them using those indexes (<code
                                        class="common">currentSceneIndex</code>).</p>
                            <p>We also have created a pre-render function that prints the current scene name once per 60
                                frames.</p>
                            <p>In a browser rendering loops at 60fps max, we will see the current scene name printed
                                every second, and as we click, the scene switches and the printed scene name changes.
                                Below is the Example 1 output from two clicks in 5 seconds:</p>
                            <p class="indent"><code class="common green" ng-style="$ctrl.codeStyle"> Main<br/> Main<br/>
                                mySecondScene<br/> mySecondScene<br/> Main </code></p>
                            <div class="section-footer">
                                <p>See <a>Scene</a> for details.</p>
                            </div>
                        </article>
                    </section>
                    <section class="tutorial-content">
                        <h1>Sculpt</h1>
                        <article>
                            <p>Sculpt is essentially the 3D object container class.</p>
                            <p>As you might have noticed, the Rodin library is based on the Three.js library (thanks
                                Ricardo Cabello and co.), and in Three.js all objects are extensions of <code
                                        class="common">THREE.Object3D</code>.</p>
                            <p>The <code class="common">Sculpt</code> class enhances the features of <code
                                    class="common">THREE.Object3D</code> objects, by binding them to <code
                                    class="common">RodinEvents </code>(See <a>EVENTS</a> for details).</p>
                            <p>As a constructor argument, Sculpt must receive an object:</p>
                            <p><code class="common"> <span class="block green">{</span> <span
                                    class="block indent">name: &ldquo;myObject&rdquo;,</span> <span class="block green">and</span>
                                <span class="block indent">threeObject: a THREE.Object3D instance,</span> <span
                                        class="block green indent">or</span> <span class="block indent">sculpt: another Sculpt instance</span>
                                <span class="block green">}</span> </code></p>
                            <p>You can also provide a <code class="common">THREE.Object3D</code> instance or a <code
                                    class="common">Sculpt</code> instance directly, without putting them in an object as
                                a <code class="common">key:value</code> pair (See Example 2).</p>
                            <p>With events enabled, all <code class="common">Sculpt</code> objects will be listening to
                                fired <code class="commn">RodinEvents</code> and executing their corresponding event
                                handlers if any.</p>
                            <p>Let&rsquo;s see a basic example to make it clear:</p>
                            <div id="ex2" class="code-box">
<pre id="rodinCode" class="code-block">                            <code class="code">
                                import * as RODIN from 'rodin/core';
                                RODIN.start();

                                let sphere = new RODIN.Sculpt(
                                    new THREE.Mesh(
                                        new THREE.SphereGeometry(1, 12, 12),
                                            new THREE.MeshBasicMaterial({ wireframe: true })
                                    )
                                );

                                RODIN.Scene.add(sphere);

                                sphere.on(RODIN.CONST.READY, function (event) {
                                    event.target.position = new THREE.Vector3(0, 1.6, -2);
                                });

                                sphere.on(RODIN.CONST.UPDATE, function (event) {
                                    event.target.rotation.y += RODIN.Time.delta / 1000;
                                });

                                sphere.on(RODIN.CONST.UPDATE, (event) =&gt; {
                                    event.target.rotation.z += RODIN.Time.delta / 10000;
                                });

                            </code>
                        </pre>
                                <p class="code-box-title">Example 2</p>
                            </div>
                            <p>In Example 2, we create a Three.js sphere mesh object and pass it to a <code>RODIN.Sculpt()</code>
                                constructor.</p>
                            <p>Next, we add the <code class="common">sphere</code> and then three event listeners to the
                                current(active) scene.</p>
                            <p>Though not recommended, you can also gain access to the <code class="common">THREE.Object3D</code>
                                object that is wrapped by the <code class="common">Sculpt</code> class using a
                                reference, for example: <code class="common">sphere. _threeObject</code>.</p>
                            <p><strong>The first</strong> handler function goes to <code class="common">RODIN.CONST.READY</code>
                                event (See all event types listed in EVENTS chapter). Whenever the Sculpt object is
                                created, it fires a <code class="common">READY</code> event. This handler then sets the
                                needed position to the event target (which is the <code class="common">sphere</code>
                                itself).</p>
                            <p><strong>The second</strong> handler function goes to <code class="common">RODIN.CONST.UPDATE</code>
                                event. This event is fired for all Sculpt objects of active scenes on each iteration of
                                rendering during <code class="common">animationFrame</code> loop, after <code
                                        class="common">preRender</code> functions and before <code class="common">postRender</code>
                                functions.</p>
                            <p>This handler rotates the sphere by a 1000th fraction of <code class="common">RODIN.Time.delta</code>
                                (the time elapsed after previous render call, e.g. 16.6ms for 60fps, 33.3ms for 30fps
                                etc).</p>
                            <p>In simpler words - this function is called on each rendering event, which generally
                                occurs 60 times per second, and each time rotates the sphere by an angle that depends on
                                how intense the calls are (60fps, 30fps, 90fps). The higher the fps rate, the smaller
                                the angle of each rotation.</p>
                            <p>This way we can make sure that the rotation speed won&rsquo;t vary on different devices
                                with different fps rates.</p>
                            <p><strong>The third</strong> handler function again goes to <code class="common">RODIN.CONST.UPDATE</code>
                                event. This handler also rotates the sphere, but on a different axis and 10 times slower
                                (try to understand why). This shows that Sculpt objects can have multiple handlers for
                                each event and they all will be executed correspondingly.</p>
                            <p>Sculpt class does not provide public functions for adding or removing child objects;
                                instead, Sculpt has the <code class="common">parent</code> attribute you can set. By
                                setting the<code class="common">parent</code> attribute, you remove the object from the
                                current parent and add it to the target parent, <strong>while maintaining the objects&rsquo;
                                    global position, rotation, and scale</strong> (unlike Three.js).</p>
                            <div class="section-footer">
                                <p>See <a>Sculpt</a> for details.</p>
                            </div>
                        </article>
                    </section>
                    <section class="tutorial-content">
                        <h1>Events</h1>
                        <p>There is a number of custom event types used in Rodin:</p>
                        <p class="indent"><code class="common"> READY = 'ready';<br/> UPDATE = 'update';<br/> START =
                            'start';<br/> STOP = 'stop';<br/> COMPLETE = 'complete';<br/> GAMEPAD_HOVER =
                            'gamepadhover';<br/> GAMEPAD_HOVER_OUT = 'gamepadhoverout';<br/> GAMEPAD_BUTTON =
                            'gamepadbutton';<br/> GAMEPAD_BUTTON_DOWN = 'gamepadbuttondown';<br/> GAMEPAD_BUTTON_UP =
                            'gamepadbuttonup';<br/> GAMEPAD_BUTTON_CHANGE = 'gamepadbuttonchange'; </code></p>
                        <p>These constants are available through <code class="common">RODIN.CONST.{EVENT}</code>. All
                            those events can be used, wrapped in the <code class="common">RodinEvent</code> class. Rodin
                            has included this custom class because the controllers do not have the event concept
                            natively; all they do is change state and value. So with Rodin, we&rsquo;ve created a more
                            JS developer-friendly interface to work with. You have seen the events usage in Example 2.
                            There are more samples available in our platform.</p>
                        <p>The RodinEvent constructor requires a target object and parameters object:</p>
                        <p><code class="block common"> { <span class="block indent"> type: 'event',<br/> domEvent: null,<br/> button: null,<br/> hand: '',<br/> controller: null </span>
                            } </code></p>
                    </section>
                    <section class="tutorial-content">
                        <h1>Animation</h1>
                        <p>The <code class="common">AnimationClip</code> class is for creating animation clips on Sculpt
                            objects. To create animation clips on Sculpt objets, we create a new instance of the class,
                            provide the parameters that need to be animated (position, rotation, scale, etc.), the
                            duration in milliseconds, and the target value of the parameters. Optionally, we can provide
                            the starting value as well, but by default the starting value is considered the parameter&rsquo;s
                            current value at the time the animation clip was started.</p>
                        <p>Let&rsquo;s look at an example:</p>
                        <div class="code-box">
        <pre id="rodinCode" class="code-block">                            <code class="code">
                            	import * as RODIN from 'rodin/core';
                            	RODIN.start();

                            	let sphere = new RODIN.Sphere();
                            	let box = new RODIN.Box(.2, .2, .2, new THREE.MeshBasicMaterial({ wireframe: true, color: 0x996633 }));

                            	sphere.on(RODIN.CONST.READY, function () {
                            	    sphere.position.z = -2;
                            	    sphere.position.y = 2;
                            	    sphere.parent = box;
                            	});

                            	RODIN.Scene.add(new RODIN.Sculpt(new THREE.AmbientLight()));

                            	let hoverAnimation = new RODIN.AnimationClip("hoverAnim", {
                            	    scale: {
                            	        x: {from: 1.0, to: 1.5},
                            	        y: {from: 1.0, to: 1.5},
                            	        z: {from: 1.0, to: 1.5}
                            	    }
                            	});
                            	hoverAnimation.duration(200);

                            	let hoverOutAnimation = new RODIN.AnimationClip("hoverOutAnim", {
                            	    scale: {
                            	        x: 1,
                            	        y: 1,
                            	        z: 1
                            	    }
                            	});
                            	hoverOutAnimation.duration(200);

                            	box.animation.add(hoverAnimation, hoverOutAnimation);

                            	box.on(RODIN.CONST.GAMEPAD_HOVER, function () {
                            	    if (box.animation.isPlaying('hoverOutAnim')) {
                            	        box.animation.stop('hoverOutAnim', false);
                            	    }
                            	    box.animation.start('hoverAnim');
                            	});

                            	box.on(RODIN.CONST.GAMEPAD_HOVER_OUT, function () {
                            	    if (box.animation.isPlaying('hoverAnim')) {
                            	        box.animation.stop('hoverAnim', false);
                            	    }
                            	    box.animation.start('hoverOutAnim');
                            	});

                            	box.on(RODIN.CONST.READY, function () {
                            	    box.position.set(1, 1.6, -2);
                            	    RODIN.Scene.add(box);
                            	});
                            </code>

                        </pre>
                            <p class="code-box-title">Example 3</p>
                        </div>
                        <p>Starting from the first lines, we can see two new concepts - <code class="common">new
                            RODIN.Sphere();</code> and <code class="common">new RODIN.Box();</code>. These concepts are
                            time saving utilities in the Rodin library, for creating simple <code
                                    class="common">Sculpt</code>objects very quickly.</p>
                        <p>After adding a new ambient light to the scene, we start creating the animations.</p>
                        <p>The first animation clip is the <code class="common">hoverAnimation</code>. The constructor
                            receives a name &ldquo;hoverAnim&rdquo; and the parameters of the clip, that say &ldquo;change
                            the <code class="common">scale</code> of the object <code class="common">from 1.0 to
                                1.5</code> for all three axes.&rdquo; Please note that the clip has an assigned value to
                            start from. This means that no matter what the state of the object is, the scale will be set
                            to <code class="common">1.0</code> at the beginning of the animation and end up being <code
                                    class="common">1.5</code> when the animation is finished.</p>
                        <p>The duration of the animation clip is then set to <code class="common">200ms</code>.</p>
                        <p>The next animation clip is the <code class="common">hoverOutAnimation</code>. Just like the
                            <code class="common">hoverAnimation</code>, it changes the scale of the object. Please note
                            that this <code class="common">hoverOutAnimation</code> does not assign any specific value
                            to the property to start animating from. This means that whenever this animation starts, it
                            will consider the current value of the property as the starting point.</p>
                        <p>So now that we have the animation clips, let&rsquo;s assign them to an object and start/stop
                            them on some user interaction cases.</p>
                        <p>Every Sculpt object has an <code class="common">animation</code> member that is responsible
                            for controlling assigned animation clips. We add the created clips to the <code
                                    class="common">box.animation</code>, and set <code class="common">hover</code>/
                            <code class="common">hoverOut</code> event handlers to start and stop the clips accordingly.
                        </p>
                        <div class="section-footer">
                            <p>See <a>AnimationClip</a> and <a>Animation</a> for details.</p>
                        </div>
                    </section>
                    <section class="tutorial-content">
                        <h1>Time</h1>
                        <p>The <code class="common">RODIN.Time</code> class is an extended integration of the native JS
                            Date instance to our library. This class allows you to set different time speeds for each
                            scene you have and dynamically change it for advanced animation effects or calculations. In
                            simple words, in Rodin we can change the time speed wherever and whenever we want.</p>
                        <p>This class also provides utilities like <code class="common">delta</code>, that returns the
                            elapsed time in milliseconds after latest <code class="common">tick</code> (<code
                                    class="common">tick</code> is called on every render).</p>
                        <p>The <code class="common">delta</code>&rsquo;s value is calculated according to the current
                            time <code class="common">speed</code>.</p>
                        <p>If you go back to <a href="#ex2">Example 2</a>, you&rsquo;ll notice that the sphere rotation
                            depends on the <code class="common">RODIN.Time.delta</code>. So if we change the speed of
                            the scene by adding the following line: <code class="common block indent"> RODIN.Time.speed
                                = 0.25; </code> we will basically slow down the sphere rotation speed on both axes for
                            four times.</p>
                        <p class="note">NOTE: the rendering frequency does not depend on RODIN.Time.speed, so slowing
                            down the speed won&rsquo;t affect your FPS.</p>
                    </section>
                    <section class="tutorial-content">
                        <h1>GAMEPAD</h1>
                        <p>Rodin provides access to the majority of current VR Headset gamepads (a.k.a. Controllers),
                            including HTC Vive controllers, Oculus Touch controllers, cardboard button, Mouse, Keyboard,
                            etc.</p>
                        <p>All of the devices that help you interact with the VR experience in Rodin are considered a
                            gamepad device. This approach helps to unify the gamepad's logic.</p>
                        <p>By default, right after <code class="common">RODIN.start()</code> Rodin initializes several
                            types of gamepads that are available in the <code class="common">RODIN.GamePad</code>
                            object. All controllers are enabled and available when a corresponding device is detected.
                        </p>
                        <p>If you look at Example 3 for instance, you can see that no gamepad initialization is present
                            in the code; however, when running within HTC Vive, you&rsquo;ll be able to see the default
                            Vive gamepads being tracked and interacting with the box when hovering in and out. The same
                            scenario works for mouse, Oculus Rift, and cardboard.</p>
                        <p>Of course, you can make custom gamepads for each device, and as long as you keep the Class
                            structure, the custom gamepad will be fully functional. (We will leave this now, and go into
                            details in final documentation, sorry :)</p>
                        <p>Let&rsquo;s make another example with gamepad interaction:</p>
                        <div class="code-box">
<pre id="rodinCode" class="code-block">                            <code class="code">
                            	import * as RODIN from 'rodin/core';
                            	RODIN.start();

                            	RODIN.Scene.add(new RODIN.Sculpt(new THREE.AmbientLight()));

                            	let hoverAnimation = new RODIN.AnimationClip("hoverAnim", {scale: {x: 1.2, y: 1.2, z: 1.2}});
                            	hoverAnimation.duration(100);

                            	let hoverOutAnimation = new RODIN.AnimationClip("hoverOutAnim", {scale: {x: 1, y: 1, z: 1}});
                            	hoverOutAnimation.duration(100);

                            	for (let i = 0; i &lt; 40; i++) {
                            	    let box = new RODIN.Box(.2, .2, .2, new THREE.MeshNormalMaterial({wireframe: true, color: 0x996633}));
                            	    box.animation.add(hoverAnimation, hoverOutAnimation);
                            	    box.on(RODIN.CONST.READY, onReady);
                            	    box.on(RODIN.CONST.GAMEPAD_HOVER, hover);
                            	    box.on(RODIN.CONST.GAMEPAD_HOVER_OUT, hoverOut);
                            	}

                            	function onReady(evt) {
                            	    evt.target.position.set(Math.random() * 4 - 2, Math.random() * 4 - 0.4, Math.random() * 4 - 2);
                            	    RODIN.Scene.add(evt.target);
                            	}
                            	function hover(evt) {
                            	    if (evt.target.animation.isPlaying('hoverOutAnim')) {
                            	        evt.target.animation.stop('hoverOutAnim', false);
                            	    }
                            	    evt.target.animation.start('hoverAnim');
                            	}
                            	function hoverOut(evt) {
                            	    if (evt.target.animation.isPlaying('hoverAnim')) {
                            	        evt.target.animation.stop('hoverAnim', false);
                            	    }
                            	    evt.target.animation.start('hoverOutAnim');
                            	}
                            </code>
                        </pre>
                            <p class="code-box-title">Example 4</p>
                        </div>
                        <p>That&rsquo;s it! We&rsquo;ve just created 40 randomly positioned boxes with hover and hover
                            out actions.</p>
                        <div class="section-footer">
                            <p>See <a>GamePad</a> for details.</p>
                        </div>
                    </section>
                </div>
            </div>
        </div>

    </div>
</div>